// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var $$String = require("bs-platform/lib/js/string.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var line = "488   393   393   3939";

function stringAfter(s, n) {
  return $$String.sub(s, n, s.length - n | 0);
}

function pChar($$char, input) {
  var a = $$String.sub(input, 0, 1);
  var rest = stringAfter(input, 1);
  var match = a === $$char;
  if (match) {
    return /* Some */[/* record */[
              /* rest */rest,
              /* value */a
            ]];
  } else {
    return /* None */0;
  }
}

function pSpace(param) {
  return pChar(" ", param);
}

function isCharNum($$char) {
  try {
    Caml_format.caml_int_of_string($$char);
    return true;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return false;
    } else {
      throw exn;
    }
  }
}

function getNext(input) {
  var match = input.length === 0;
  if (match) {
    return /* None */0;
  } else {
    return /* Some */[$$String.sub(input, 0, 1)];
  }
}

function pNumber(_$staropt$star, _input) {
  while(true) {
    var input = _input;
    var $staropt$star = _$staropt$star;
    var nums = $staropt$star ? $staropt$star[0] : "";
    var isParsedNums = nums.length !== 0;
    var next = Belt_Option.getWithDefault(getNext(input), "");
    var isNextNum = isCharNum(next);
    var exit = 0;
    if (isParsedNums) {
      if (isNextNum) {
        exit = 1;
      } else {
        return /* Some */[/* record */[
                  /* rest */input,
                  /* value */nums
                ]];
      }
    } else if (isNextNum) {
      exit = 1;
    } else {
      return /* None */0;
    }
    if (exit === 1) {
      _input = stringAfter(input, 1);
      _$staropt$star = /* Some */[nums + next];
      continue ;
    }
    
  };
}

function any(_parsers, input) {
  while(true) {
    var parsers = _parsers;
    if (parsers) {
      var parsed = Curry._1(parsers[0], input);
      if (parsed) {
        return parsed;
      } else {
        _parsers = parsers[1];
        continue ;
      }
    } else {
      return /* None */0;
    }
  };
}

var parsers_001 = /* :: */[
  (function (eta) {
      return pNumber(/* None */0, eta);
    }),
  /* [] */0
];

var parsers = /* :: */[
  pSpace,
  parsers_001
];

function parse(parsers, _input) {
  while(true) {
    var input = _input;
    var match = any(parsers, input);
    if (match) {
      var a = match[0];
      var match$1 = a[/* rest */0].length === 0;
      if (match$1) {
        console.log("Successfully parsed");
        return /* () */0;
      } else {
        _input = a[/* rest */0];
        continue ;
      }
    } else {
      return Pervasives.failwith("Could not parse input");
    }
  };
}

Belt_List.fromArray(Fs.readFileSync("src/input-1", "utf8").split("\n"));

var nums = parse(parsers, line);

console.log(nums);

exports.line = line;
exports.stringAfter = stringAfter;
exports.pChar = pChar;
exports.pSpace = pSpace;
exports.isCharNum = isCharNum;
exports.getNext = getNext;
exports.pNumber = pNumber;
exports.any = any;
exports.parsers = parsers;
exports.parse = parse;
exports.nums = nums;
/*  Not a pure module */
